import { Resend } from 'resend';

// src/transport.ts

// package.json
var version = "4.0.0";

// src/transport.ts
var RESEND_ERROR_CODES_BY_KEY = {
  missing_required_field: 422,
  invalid_access: 422,
  invalid_parameter: 422,
  invalid_region: 422,
  rate_limit_exceeded: 429,
  missing_api_key: 401,
  invalid_api_Key: 403,
  invalid_from_address: 403,
  validation_error: 403,
  not_found: 404,
  method_not_allowed: 405,
  application_error: 500,
  internal_server_error: 500
};
var ResendTransport = class _ResendTransport {
  constructor(options) {
    this.name = "ResendMailTransport";
    this.version = version;
    const { apiKey = "" } = options;
    this._client = new Resend(apiKey);
  }
  static makeTransport(options) {
    return new _ResendTransport(options);
  }
  send(mail, callback) {
    var _a, _b, _c;
    if (!mail.data.to || !mail.data.from) {
      return callback(new Error('Missing required fields "to" or "from"'), null);
    }
    this._client.emails.send({
      subject: (_a = mail.data.subject) != null ? _a : "",
      from: this.toResendFromAddress(mail.data.from),
      to: this.toResendAddresses(mail.data.to),
      cc: this.toResendAddresses(mail.data.cc),
      bcc: this.toResendAddresses(mail.data.bcc),
      html: ((_b = mail.data.html) == null ? void 0 : _b.toString()) || "",
      text: ((_c = mail.data.text) == null ? void 0 : _c.toString()) || "",
      attachments: this.toResendAttachments(mail.data.attachments)
    }).then((response) => {
      var _a2;
      if (response.error) {
        const statusCode = (_a2 = RESEND_ERROR_CODES_BY_KEY[response.error.name]) != null ? _a2 : 500;
        throw new Error(`[${statusCode}]: ${response.error.name} ${response.error.message}`);
      }
      callback(null, response.data);
    }).catch((error) => {
      callback(error, null);
    });
  }
  toResendAddresses(addresses) {
    if (!addresses) {
      return [];
    }
    if (typeof addresses === "string") {
      return [addresses];
    }
    if (Array.isArray(addresses)) {
      return addresses.map((address) => {
        if (typeof address === "string") {
          return address;
        }
        return address.address;
      });
    }
    return [addresses.address];
  }
  toResendFromAddress(address) {
    if (!address) {
      return "";
    }
    if (typeof address === "string") {
      return address;
    }
    return `${address.name} <${address.address}>`;
  }
  toResendAttachments(attachments) {
    if (!attachments) {
      return [];
    }
    return attachments.map((attachment) => {
      if (!attachment.filename || !attachment.content) {
        throw new Error("Attachment is missing filename or content");
      }
      if (typeof attachment.content === "string") {
        return {
          filename: attachment.filename,
          content: Buffer.from(attachment.content)
        };
      }
      if (attachment.content instanceof Buffer) {
        return {
          filename: attachment.filename,
          content: attachment.content
        };
      }
      throw new Error("Attachment content must be a string or a buffer");
    });
  }
};

export { ResendTransport };
